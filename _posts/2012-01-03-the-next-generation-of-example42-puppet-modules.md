---
layout: blog
title: The Next Generation of Example42 Puppet modules
created: 1325563356
---
<p><strong>Update 20130902</strong>: Read the post <a href="http://www.example42.com/?q=NextGen_Modules_Lessons_learned">Next Gen Modules: Lessons Learned</a> for current ideas and considerations about NextGen modules</p><h2>Introduction</h2><p>The Example42 Puppet modules collection has tried to establish a standard, integrated, reusable and coherent way to manage Puppet modules based on the principles exposed in a pair of <strong>PuppetCamp</strong> presentations:&#160;<a href="http://www.lab42.it/presentations/puppetmodules/puppetmodules.html" title="Puppet Modules Standards and Interoperability">Puppet Modules Standards and Interoperability</a>&#160;and <a href="http://www.slideshare.net/Alvagante/reuse-your-puppet-modules-5403529" title="ReUse Your Modules!">ReUse Your Modules!</a></p><p>It has been initially developed and conceived for Puppet versions<strong> 0.2x</strong> and has introduced and followed some concepts that I've found quite useful in various situations, such as monitoring and firewall abstraction, "include and play" approach without the enforcing of custom logic, easily extendable multiple operating system support, attempt (only partially successful) to separate "core" module elements from custom ones, standard structure that allows scaffolding and relatively quick creation and upgrade of modules.</p><p>Still, experience and the evolution of the Puppet language have suggested new and better ways of "<em>doing things with Puppet</em>" and, more important, most of the modules are&#160;going to have some issues (as probably a relevant part of the existing Puppet code in the world) when Puppet 2.8 will be released and variables dynamic scoping will be discontinued.</p><p>For this reason I've decided to <strong>rewrite</strong> the whole modules set from scratch and make a new generation of Puppet modules, that is going to be compliant only with Puppet Masters with version major than 2.6 and will benefit of all the experience (mistakes?) made with the current modules.</p><p>The effort is not as big as one may think, given the way modules are organized (most of the existing changes are in params.pp and custom module-specific defines are placed in dedicated files that can be imported) and the fact that module's generation is based on the scaffolding of a "foo template".</p><p>Still there's much work to do ...</p><h2>Existing and NextGen features</h2><p>You can find the next generation of Puppet modules at&#160;<a href="http://github.com/example42/puppet-modules-nextgen" title="Example42 Puppet Modules Next-gen">http://github.com/example42/puppet-modules-nextgen</a></p><p>consider that currently that module set is <strong>experimental work</strong>, not ready for production nor for testing, but it has the base structure that can give glimpses of what is going to become.</p><p>All the application related modules are git submodules contained in independent git repositories (this is a first fix and evolution of the older one-repo modules set that will allow better integration in the Puppet Module Forge and possibly, better cherry picking of the desired modules), but some special modules and directories are part of the main git repo.</p><p>The main features of the modules are:</p><p>- Coherent and <strong>standardized structure</strong>, logic and usage based on best practices</p><p>- <strong>Cross OS support</strong> (main targets are Redhat and Ubuntu derivatives)</p><p>- Use of <strong>parametrized classes</strong> and fully qualified variables for Puppet 2.8 compliance (with support for <strong>mixed approach</strong>) (This is a "NextGen" feature).</p><p>- <strong>Extreme customization</strong> options without any change to the core module (NextGen)</p><p>- Optional <strong>integration with Puppi</strong> </p><p>- Optional support of <strong>monitoring and firewalling abstraction</strong></p><p>- <strong>Decommissiong support</strong>: you can remove (almost) whatever you've added with a module, Monitoring elements included.</p><p>- <strong>Auditing support</strong>: you can audit changes that the modules would do to existing files, before applying them (NextGen)</p><p>- Integrated <strong>rspec-puppet</strong> tests (NextGen)</p><p>- Embedded documentation compliant with <strong>PuppetDoc</strong></p><p>- <strong>Modules scaffolding</strong> based on different kind of basic foo templates</p><p>- <strong>Compact code</strong> optimized for compilation and reporting times. (NextGen)</p><h2>Parametrized classes and variables</h2><p>All the main <strong>classes </strong>are now <strong>parametrized</strong>: you can pass all the parameters they use as explicit arguments.</p><p>This allows better <strong>introspection</strong> on the parameters used by the classes, with a coherent and <strong>standard API</strong> (at least inside Example42 modules) to the modules functionality, but introduces new challenges in the definition of a whole Puppet setup:</p><p>- You can use the same parametrized class only once</p><p>- Besides internal defaults, you have to explicitly declare all the parameters you want to pass.</p><p>Since I wanted to provide a <strong>rich and standard</strong> set of common parameters, that allows users to affect the behavior of the class without changing it, this could result in having a lot of similar and redundant code parts to manage these arguments &#160;(such as if to enable automatic monitoring and what tools to use).</p><p>For this reason all the next-gen classes have these features and <strong>twists</strong>:</p><p>- all the parameters' defaults are defined in the <strong>params.pp</strong> class where cross OS variations are managed and top scope variables eventually used to redefine defaults</p><p>- you can therefore use <strong>top scope variables</strong> (such as the ones defined in an External Node Classifier) instead of parameters</p><p>- you can <strong>mix top scope variables and class parameters</strong> (at first look this might not sound a good idea, but keep on reading...)</p><p>- <strong>parameters</strong>, if defined, <strong>always override</strong> the module internal defaults and top scope variables.</p><p>So, let's take the <a href="https://github.com/example42/puppet-openssh" title="OpenSSH"><strong>openssh</strong></a> module (which is actually the one I'm testing for different cases).</p><p>You can use it in both the <em>old</em> include way:</p><pre>include openssh</pre><p>or as a parametrized class:</p><pre>class { "openssh" : }</pre><p>by default this just installs the relevant package, starts the relevant service and doesn't change configuration files.</p><p>You can provide parameters in two ways.</p><p>1- Define top scope variables (the ones you define in a ENC or in site.pp) and include the class:&#160;</p><pre>$::openssh_template = "example42/openssh/sshd.config.erb" 
include openssh</pre><p>2- Pass the arguments in the parametrized class:</p><pre>class { "openssh":&#160; 
 template =&gt; "example42/openssh/sshd.config.erb",
}</pre><p>and you can mix top scope variables and class parameters to manage site-wide settings reducing the verbosity of common arguments:</p><pre>$::monitor = true<br />$::monitor_tools = [ "nagios" , "puppi" , "monit" , "munin" ]<br />$::puppi = true<br />class { "openssh":&#160; 
 template =&gt; "example42/openssh/sshd.config.erb",
}</pre><p>The above does the same of:</p>
<pre>class { "openssh":&#160; 
  template      =&gt; "example42/openssh/sshd.config.erb",
  monitor       =&gt; true,
  monitor_tools =&gt;  [ "nagios" , "puppi" , "monit" , "munin" ],
  puppi         =&gt; true,
}
</pre><p>which, if repeated for many classes can actually be too much redundant.</p><p>Needless to say that the values of the top scope variables can be assigned via <strong>Hiera</strong>, Extlookup or other functions that set specific values to the variable according to custom logic.</p><h2>Customize everything, modify nothing</h2><p>You have already had a glimpse of the parameters you can pass to these classes: the path of the template to use for the main configuration file, for example.</p><p>The whole discussion about externalizing Puppet data sources and separating it from the module logic with functions like Hiera is, IMHO, a very important but not resolutive step towards full modules' reusability.</p><p>A module, according to me, should not enforce the way it provides its configuration files (static files, eventually based on an array of possible sources, &#160;templates or even concatenated files), it should allow site specific customizations where existing resources are modified or new ones added, and should be adaptable to different scenarios.</p><p>To our openssh class you can pass variables like:</p><pre>class { "openssh":  
  source   =&gt; [ "puppet:///modules/lab42/openssh/sshd_config-${hostname}" , 
                "puppet:///modules/lab42/openssh/sshd_config" ], 
}</pre><p>So you can specify the name of the Puppet path &#160;of the static files to <strong>source</strong> (in this case an array).</p><p>But you can also do something like:</p>
<pre>class { "openssh":  
  source_dir       =&gt; "puppet:///modules/lab42/openssh/" , 
  source_dir_purge =&gt; false, 
}</pre><p>in order to provide the whole content of the configuration directory based on the path specified in <strong>source_dir</strong> (in this case, with the <strong>source_dir_purge</strong> option disabled, without removing eventual existing files on the local system that are not in the source directory on the PuppetMaster).</p><p>But if you prefer to use <strong>templates</strong>, or they are more fitting for your setup, you can use the template argument instead of the source one (note that the parameters source and template can't coexist):</p>
<pre>class { "openssh":  
  template =&gt; "lab42/openssh/sshd_config.erg" , 
  options  =&gt; { 
    'LogLevel =&gt; 'INFO',
    'PermitRootLogin =&gt; 'yes',
    'ListenAddress' =&gt; '0.0.0.0',
  },
}</pre><p>Here besides the usage of a custom <strong>template</strong>&#160;you can specify, as an hash, whatever custom <strong>options </strong>you may want to use in your template. They&#160;needn't to be explicitely added as parameters of the openssh class, so you can actually provide custom parameters to use in your templates without the need to explicit them in the called class.</p><p>Given the above example, in your own&#160;lab42/openssh/sshd_config.erg template , you can use the custom values provided in the <strong>options </strong>hash in this way:</p>
<pre>[ ...]
# Direct usage example 
PermitRootLogin &lt;%= options['PermitRootLogin'] %&gt;
LogLevel &lt;%= options['LogLevel'] %&gt;
# Conditional usage example, with default value setting
&lt;% if scope.lookupvar("openssh::options['ListenAddress']") then -%&gt;
ListenAddress &lt;%= options['ListenAddress'] %&gt;
&lt;% else -%&gt;
ListenAddress 0.0.0.0 #&#160;Default value
&lt;% end -%&gt;
</pre><p>Now, even if this approach has its evident&#160;<strong>disadvantages</strong> (not exactly easy to use, you need to place some extra logic in the template to manage defaults in order to avoid the danger of having blank fields for options not explicitly passed) it provides a mathod to affect, in a <strong>completely independent</strong> way, the main class behavior without touching anything of its module.</p><p>Still this might not cover all your customization needs, you may want to add custom resources to the basic openssh class, or redefine arguments for existing arguments for which there's not already a class parameter. Well, you can specify a custom subclass to automatically include:</p>
<pre>class { "openssh":  
  my_class =&gt; "openssh::lab42", 
}</pre><p>This make the class openssh include openssh::lab42 a custom class that may inherit or not the main openssh class (inheritance would be needed only when you have to modify existing resources defined in openssh).&#160;</p><p>Note that in order to allow class inheritance your custom class name should be something like openssh::<em>myname</em> (and not myname::openssh).</p><p>So, if you would like (as good and recommended practice) to place your custom classes in a custom module&#160;(eventually named&#160;<em>myname</em>), you might need to explicitly &#160;<strong>import</strong>&#160;somewhere your <em>myname</em> module with all your custom classes, templates and files, since class autoloading in this case wouldn't work (it actually depends on the Puppetmaster's version: on 2.6 you need to explicitly import your myname module with custom classes, on 2.7 it seems not necessary).</p>
<p>In any case, as usual, all these are options left to the module's user: usage of custom source files or whole configuration directories, addition of custom classes and resources, usage of custom templates with custom extra options are possible without any modification of the core module, but, if you&#160;simply get the module and modify it directly to fit your needs, adding there resources, custom arguments or whatever, you are free to do that.</p><p>Maybe this won't be not the most "reusable way", it will break upstream compatibility (but Github pull requests are always welcomed ;-), but will work for you.</p><p>And this is what matters.</p><h2>"Common" options and features</h2><p>Most, if not all, the next-gen modules are going to have a set of parameters that affect their basic behavior.&#160;</p><p>They are common in the sense that you'll find them in all the Example42 modules (most of these features are actually already present in the current set) but actually they are not so common in the world of Puppet modules.</p><p>Some are related to the <strong>decommissioning of resources</strong>: as whoever uses Puppet knows, if you want to remove something deployed via Puppet you can't simply comment or remove the Puppet code that placed it. You need to explicitly tell Puppet to remove the resource.</p><p>This can be a big PITA in some cases or can be just a matter of typing:</p>
<pre>class { "openssh":  
  absent =&gt; true, 
}</pre><p>This not only removes the openssh package, its configuration files and the service but all the relevant monitoring configurations that the module provided (more on that later). You get it? Decommissioning is automatically done on nasty beasts like Nagios configurations, Monit control files and so on..</p><p>Similarly you can specify:</p>

<pre>class { "openssh":  
  disable =&gt; true,
}</pre><p>in order to keep the openssh package but disable its service (and the relevant monitoring).</p><p>And you can also set:</p>

<pre>class { "openssh":   
  disableboot =&gt; true, 
}</pre><p>for the specific cases (typically when the service is managed by a cluster) where you don't want to start the service at boot but also don't want to check if it's running and eventually stop it during a Puppet run.</p><p>Nothing new, up to now, these features are already present in the current modules, even if managed in a less elegant way (now there are sub classes like openssh::absent to include and generally more verbosity in the module). A new addiction is an option like this:</p>
<pre>class { "openssh":   
  audit_only =&gt; true, 
}</pre><p>which does what it suggests. When you specify it the class doesn't change any existing configuration file, it just activates Puppet's <strong>audit</strong> metaparameter and lets you see what are the changes that the class would make to your files (a sort of noop run with central reporting of the expected changes). Should be useful to see and prevent the disasters you're going to distribute when applying your Puppet modules on existing nodes.</p><p>There are various <strong>other parameters</strong> that you cat pass to the class, such as: package, service, service_status, process, process_args, config_file_mode, config_file_owner, config_file_group, config_file_init, pid_file, data_dir, log_dir, log_file, port, protocol.</p><p>For them there's not the "top scope variable" equivant since, generally, they are for module's internal use and are not expected to be modified, normally, but still you can pass them as parameters to the class.</p><p>In the <strong>openssh/manifest/params.pp</strong> file the right values for the main Operating Systems (or at least Linux distros) are already set, but there are special cases where it can be &#160;nice to have the opportunity to alter them.</p><p>For example you may need to use custom package names, built internally, which use custom service names and process names,&#160;or you may need to change the owner of the configuration file(s) to allow "<em>modifications by non privileged users ;-)</em>"or make some tweaks to the resources to monitor (various of the above parameters are used just for the monitoring abstraction and the Puppi stuff).</p><p>Just note that changing these parameters may yield to untested and unpredictable results (for example the port argument is used for monitoring and it doesn't necessarily reflect a parameter in the configuration file if it's not explicitly used in a relevant template).</p><p>Finally, talking about "common" features, the modules are supposed to have <strong>cross Operating Systems compatibility</strong>, they should work for <strong>RedHat 5/6 and derivatives</strong>,&#160;<strong>Debian 5/6 and derivatives</strong>,&#160;<strong>Ubuntu 10.04 and later</strong> (I'm fed up to quarrel with Ubuntu 8.04 operatingsystem fact). Suse support sooner or later will probably be introduced, Solaris too, eventually. Generally speaking development of alternative systems support is done upon necessity: when I'll have to work on these OS, the relevant support will be introduced (call it <em><strong>job driven development</strong></em> ;-).</p><h2>Monitoring and firewalling abstraction</h2><p>One of the features I'm proudest of, in the Example42 modules, is the <strong>monitoring abstraction approach:&#160;</strong>In the modules I define <strong>what to monitor, not how</strong>.</p><p>It has proven to be extremely powerful and useful even if I managed to write "connectors" only for a limited number of monitoring tools: <strong>Nagios</strong>, <strong>Monit</strong>, <strong>Puppi</strong> (more on this later) and, even if they auto configure themselves, <strong>Munin</strong> and <strong>Collectd</strong>.</p><p>Again, I didn't add new "tools" because I hadn't the opportunity to use them in a "real world", but I'm quite confident that the abstraction model works also for most of the cases, eventually with some tweak.</p><p>Basically the point is that, if you want to monitor the resources (typically the listening port and the running process) provided by a class you can add these parameters :</p>
<pre>class { "openssh":  
  monitor        =&gt; true,
  monitor_tool   =&gt; [ 'nagios','puppi','monit','munin' ], 
  monitor_target =&gt; $ipaddress_eth1,
}</pre><p>With the above parameters you enable the monitoring of Openssh with the specified monitoring tools specifying the Ip address to use as target for monitoring (by default is $ipaddress and you generally don't need to define it, here it was just placed for reference).</p><p>Note that, as most of the other arguments and as shown before, you can use top scope variables ( for example $::openssh_monitor_tool ) to set these configurations, but, most important, you can set a "site wide" general behavior with the variables <strong>$::monitor</strong> , <strong>$::monitor_tool</strong> and <strong>$::monitor_target</strong> and have per module overrides with the arguments written in the example above or the analog variables:&#160;<strong>$::openssh_monitor</strong> , <strong>$::openssh_monitor_tool</strong> and <strong>$::openssh_monitor_target</strong> .</p><p>Actually the setting of general top scope variables that might be overriden, case per case, by parametrized class specific arguments is the real reason that can justify the usage of the mixed approach.</p><p>A similar approach is used for automatic firewalling of the ports provided by the module.</p><p>You can set these parameters:</p>
<pre>class { "openssh":  
  firewall      =&gt; true,
  firewall_tool =&gt; [ 'iptables' ], 
  firewall_src  =&gt; "0.0.0.0/0",  # This is the default value
  firewall_dst  =&gt; "$ipaddress", # This is the default value
  port          =&gt; "22",         # This is the default value
  protocol      =&gt; "tcp",        # This is the default value
}</pre><p>as you see most of them have sensible defaults and are reported here as reference. The only firewall tool currently supported is Example42's iptables module, but it's possible, as for the monitor metamodule, to create connectors for other modules and eventually also for a central network firewall.</p><p>One of the features of the existing module set that is probably not going to be implemented in the next gen, is the backup abstraction. It's based on similar logic (a module defines what to backup and then in a backup metamodule are defined the connectors for different backup tools), but, honestly, it has not been really used up to now.</p><p>The underlining idea behind all these abstactions, is that somehow <strong>is reductive to use a Puppet module JUST to configure an application</strong>: a module inherently may have a lot of information about it: what are its components (package and service names, configuration files, but also, with limited extra effort, process names, listening ports, log and data paths...), the services it provides, their dependencies.</p><p>All this information can and should be used for many infrastructure activities: monitoring, firewalling, backup, maybe storage management, possibly network configuration, dependencies provisioning and, why not, local access to relevant information...</p><h2>Oh My Puppi!</h2><p>Sometimes I feel like I really never managed to express properly <strong>what is Puppi </strong>and what it can do. <br />The fact that even in the work environment where I introduced it (where we deploy dozens of different applications each day with it, either with a single command line, a cronjob, a mcollective command or an automated task) people make confusion between Puppet and Puppi (yes the name doesn't help) should make me ponder about this.</p><p>Let's try to summarize in a few words what is Puppi.</p><p>Puppi has basically two different and indipendent functions:<br />- <strong>Deploy applications</strong><br />- <strong>Get information </strong>about the system</p><p>More concretely Puppi is a <strong>Puppet module </strong>that installs on a system a <strong>bash command </strong>and all the scripts and files that it needs to perform its subcommands.</p><p>The Puppet module can be imported indipendently (yes, you can use it without the whole Example42 bunch) and just included in your nodes.</p><p>Once you have it you have at disposal defines, in Puppet language, that allow you to perform the above functions.</p><p>In order to manage application deployments there's not much effort to achieve appreciable results. For example, this define:</p>
<pre>puppi::project::war { "myapp":
    source      =&gt; "http://repo.example42.com/deploy/prod/myapp.war",
    deploy_root =&gt; "/usr/share/tomcat/webapps",
}</pre><p>makes it possible to issue the command "<strong>puppi deploy myapp</strong>" on the node where you placed it.</p><p>What that command does, what are the different <em>things</em> you can deploy and the options you have to customize the procedure is better described elsewhere in this site (hint: look at the top menu).</p><p>For the second function, "get information about the system", you have to use other defines for specific Puppi commands. Out of the box Puppi already provides some output to show when you type <strong>puppi check</strong>, <strong>puppi info </strong>or <strong>puppi log</strong> (some system wide information is shown in these cases) but it becomes more interesting and powerful when application specific information is made available (for example where are its logs, its configuration files, what's its status and if it's working properly).</p><p>The Example42 modules (many of the existing and all the NextGen ones) have <strong>integrated optional Puppi support</strong>.</p><p>That is you can use them also without using Puppi, as you can use Puppi without Example42 modules, but if you use Example42 modules and activate Puppi, some <strong>magic happens</strong>. Activate Puppi with:</p>
<pre>class { "openssh":  
  puppi        =&gt; true,
  puppi_helper =&gt; "myhelper", # Default is "standard"
}</pre><p>or, as you can guess by now, with the top scope variable $::puppi set to true.&#160;</p><p>Now the <strong>bad news</strong>: the implementation of Puppi for the NextGen modules still doesn't exists (!?).</p><p>I've totally changed the way to provide data for Puppi in the module.<br />Up to now modules created various files that were (are) used for the various Puppi subcommands.<br />The new approach is lighter and moves much of the work on the local system: it just creates a single yaml file containing all the variables and parameters used by the module (yes, all the "Knowledge that Puppet alreeady knows on the system: names, paths and so on"). The puppi_helper is just one more variable that will allow the personalize the scripts that will use those variables in order to yield custom outputs.&#160;</p><p>Still there's not yet a <em>Puppi something</em> on the local system able to do sane things with that yaml.</p><p>I don't expect it will be difficult to do that but I still have to figure out a sane way to keep backward compatibility and if the new Puppi will be a Puppet face (this would make it unfit for Puppet 2.6 and this bothers me).</p><p>So not much more to say about Puppi here, let talk about...</p><h2>The painful art of testing</h2><p>I must confess it. Testing and QA on the existing modules have been crap.</p><p>Fixes have been pushed upstream from different working environments on specific distros, quickly tested on other ones. Some modules were obsoleted and not updated and, even worse, the sample "Puppet infrastructure" shown on this site not always was aligned to the modules' changes and this led to brutal errors that even if quick to fix in some cases could be disturbing and misleading for new users.</p><p>I would like to be more rigorous about this, I would like to provide modules that can be updated safely, that behave consistently on different distros and "always" work out of the box.<br />I also want to introduce finally an automated testing environment for different operating systems, where not only the catalog is tested for the expected resources (as Cucumber and Rspec Puppet do) but the deployed application is working as wanted.</p><p>One of the common mistakes that is easy to do with Cucumber Puppet or Rspec Puppet is just to check if Puppet does what it is expected to do: I define a resource and check if that resource is present on the catalog.<br />This is something that the same Nikolay Sturm, author of Cucumber Puppet has stressed in different occasions: test the logic of your modules, not if Puppet works (that's PuppetLabs' job).</p><p>In the NextGen modules I inserted some Puppet Rspec tests that try to verify some internal logic, but to be honest I'm not totally won by testing approaches based on catalog checks.</p><p>You can have a wonderful and totally sane catalog that when applied to a node breaks a service because there's a syntax error in the service's configuration file. This is something that you will never discover if you look just at the catalogue. Now, I don't dare to enter here in a discussion about best practices for managing Puppet change in production environments, for the sake of this post just let me say that I'll probably automate a procedure that builds different operating systems, runs Puppet, triggers Puppi checks and notifies the result. Eventually at each post-commit, and have softer and quicker rspec tests in the pre-commit stage.</p><p>I've called a similar approach "<a href="http://www.example42.com/?q=Test_Driven_Puppet_Infrastructures_deployment">Test Driven Puppet Infrastructure Development</a>", but people around are doing similar things with different names, approaches and tools. The value added I see is that when you write tests for your modules you are actually writing checks that you can use in your monitoring tools.</p><p>Let's finally face another characteristic of these modules: scaffolding.</p><h2>Is modules templates scaffolding a good idea?&#160;</h2><p>Looking at some answers at the <a href="http://www.example42.com/?q=feedback" title="Feedback">feedback</a> page on this site various people don't consider it so.</p><p>Maybe I haven't well expressed the advantages I see in "modules cloning" or maybe is really a bad idea.</p><p>The point is that to make new modules I always start from an existing "foo" template: the skel of a full featured module, that is cloned, renamed (by the script <strong>00_example42_scripts/module_clone.sh</strong> ) and then customized according to the application specificity.</p><p>This doesn't mean that all the modules are the same with a massive renaming, changes are added in terms of specific resources or defines according to the single applications.</p><p>The value added I see in this approach is that I can very <strong>quickly</strong> create a basic module with <strong>all the features</strong> we have seem so far.</p><p>Another plus is that modules keep a <strong>standard structure</strong>, <strong>coherent naming</strong> and parameters and relatively <strong>easy upgradability</strong>.</p><p>Still not all the applications need similar module design, so, in the NextGen, I decided to create different foo templates for different type of modules: from the typical package/service/configuration file to layouts dedicated to java or php web applications, where you can even decide if to install them from package or sources (or via Puppi).</p><p>I'm testing these different layouts with the openssh modules, we are seeing it, the wordpress and the solr ones.</p><p>Actually they are supposed to be the test beds from where to define good starting foo templates from where regenerate all the new modules.</p><p>For this reason also I'm writing this post, to gather ideas, suggestions and comments about the "nextgen" openssh module before converting it to foo and make it the <em>master of the clones</em>.</p><p>So, if you've read up to now I suppose you are interested in the topic and therefore I would love to hear your opinion about what has beed described here: any suggestion will be considered and pondered, if you think there are design issues, bad choices, wrong approaches, please let me know and argument: commenting this post or directly on GitHub.</p><p>Thanks for the attention and the patience.</p>
