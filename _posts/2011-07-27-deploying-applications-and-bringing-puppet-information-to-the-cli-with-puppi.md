---
layout: blog
title: Deploying applications and bringing Puppet information to the cli with Puppi
created: 1311777975
---
<div>With Puppet we build infrastructures, piece by piece, manifest after manifest. We control how nodes are configured, what services they provide, how they are checked.</div><div>We manage where web applications stay and sometimes how they are built, tested and deployed.</div><div>Puppet has a lot of knowledge about our systems, every catalog we receive is an unique source of data that is exactly what brings our servers to the desired state.</div><div>More information we provide in our manifests about the system, more we can do things with it.</div><div>Puppi tries to bring this knowledge to the command line.</div><div>&nbsp;</div><div><strong>PRESENT</strong></div><div>Puppi was initially developed to standardize different procedures of web applications deployments and it has evolved into a shell command that provides handy and quick actions useful for the system administrator.</div><div>Now is stable enough to have reached version 1.0 (currently in RC state) the features initially planned are present, it&#39;s used in production and no big changes are planned for this version.</div><div>See the presentation held at The PuppetCamp Europe 2011 (http://example42.com/?q=Puppi_presentation_PuppetCamp_Europe_2011) for some videos and further details.</div><div>Puppi most useful actions are:</div><div><strong>deploy</strong>, to manage the whole deploy workflow with a single keystroke</div><div><strong>check</strong>, to verify the general system&#39;s health and specific checks on the application deployed</div><div><strong>log</strong>, to quickly tail some or all the known logs&nbsp;</div><div><strong>info</strong>, to show the output of a custom set of preconfigured commands</div><div><strong>rollback</strong>, to quickly rollback a deployed application</div><div>&nbsp;</div><div>Puppi is currently entirely provided as a Puppet module, (<a href="http://github.com/example42/puppi">http://github.com/example42/puppi</a>), you include it and you have the whole puppi thing:</div><div>- the bash command <strong>/usr/sbin/puppi</strong></div><div>- its configuration directory <strong>/etc/puppi</strong>, with plenty of files and dirs configured by Puppet defines like puppi::check, puppi::info etc</div><div>- a set of (customizable) defines that build deploy procedures, like <strong>puppi::project::maven</strong> that retrieves Java artifacts generated by Maven</div><div>- some general use <strong>native scripts</strong> that are used to accomplish the different steps of a deployment</div><div>- a <strong>set of defines</strong> to populate the output of puppi actions</div><div>- some <strong>default content</strong> for puppi info, log and check actions to make puppi useful out of the box.</div><div>&nbsp;</div><div>There are not other modules prerequisites, but for full functionality you need on the systems where you place puppi these commands: wget, mail, rsync and the most common Nagios Plugins.&nbsp;</div><div>Note also that Puppi is entirely self contained, it doesn&#39;t need external services to run, once deployed, all its actions are based on local files and data: checks are local, info scripts are local, deploy procedures need only the availability of the defined source to work.</div><div>&nbsp;</div><div><strong>HOW TO USE</strong></div><div>The puppi module provides some deploy procedures that cover many typical scenarios.</div><div>For example, to retrieve a war from $source and deploy it in $deploy_root, keeping a copy for rollback and notifying $report_email, you need this:</div><div><code><tt>puppi::project::war { &quot;myapp&quot;:</tt></code></div><div><code><tt>&nbsp; &nbsp; source &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt; &quot;http://repo.example42.com/deploy/prod/myapp.war&quot;,</tt></code></div><div><code><tt>&nbsp; &nbsp; deploy_root &nbsp; &nbsp; &nbsp;=&gt; &quot;/store/tomcat/myapp/webapps&quot;,</tt></code></div><div><code><tt>&nbsp; &nbsp; report_email &nbsp; &nbsp; =&gt; &quot;sysadmins@example42.com&quot;, &nbsp; &nbsp;</tt></code></div><div><code><tt>}</tt></code></div><div>All the existing deploy procedure have a set of optional arguments that make them more flexible. Here a more complex case:</div><div><code>puppi::project::maven { &quot;supersite&quot;:</code></div><div><code>&nbsp; &nbsp; source &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt; &quot;http://nexus.example42.com/nexus/content/repositories/releases/it/example42/supersite/&quot;,</code></div><div><code>&nbsp; &nbsp; deploy_root &nbsp; &nbsp; &nbsp;=&gt; &quot;/usr/local/tomcat/supersite/webapps&quot;,</code></div><div><code>&nbsp; &nbsp; config_suffix &nbsp; &nbsp;=&gt; &quot;cfg&quot;,</code></div><div><code>&nbsp; &nbsp; config_root &nbsp; &nbsp; &nbsp;=&gt; &quot;/srv/htdocs/supersite&quot;,</code></div><div><code>&nbsp; &nbsp; document_suffix &nbsp;=&gt; &quot;css&quot;,</code></div><div><code>&nbsp; &nbsp; document_root &nbsp; &nbsp;=&gt; &quot;/srv/htdocs/supersite&quot;,</code></div><div><code>&nbsp; &nbsp; firewall_src_ip &nbsp;=&gt; $site ? {</code></div><div><code>&nbsp; &nbsp; &nbsp; &nbsp; dr &nbsp; &nbsp; &nbsp;=&gt; &quot;192.168.101.1/30&quot;,</code></div><div><code>&nbsp; &nbsp; &nbsp; &nbsp; main &nbsp; &nbsp;=&gt; &quot;192.168.1.1/30&quot;,</code></div><div><code>&nbsp; &nbsp; },</code></div><div><code>&nbsp; &nbsp; backup_retention =&gt; &quot;3&quot;,</code></div><div><code>&nbsp; &nbsp; init_script &nbsp; &nbsp; &nbsp;=&gt; &quot;tomcat&quot;,</code></div><div><code>&nbsp; &nbsp; report_email &nbsp; &nbsp; =&gt; &quot;sysadmins@example42.com&quot;,</code></div><div><code>&nbsp; &nbsp; enable &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; =&gt; &quot;true&quot;,</code></div><div><code>}</code></div><div>this does the following actions in sequence:&nbsp;</div><div>- Retrieves the maven-metadata.xml from $source,</div><div>- Blocks access from a loadbalancer IP,</div><div>- Backups the existing data for rollback operations</div><div>- Deletes older backups (3 archives are kept, instead of the default 5)</div><div>- Deploys the release war in $deploy_root,&nbsp;</div><div>- Unpacks a configurations tarball tagged with the Maven qualifier $config_suffix in $config_root,&nbsp;</div><div>- Unpacks a static files tarball tagged with the Maven qualifier $document_suffix in $document_root</div><div>- Restarts tomcat and notifies via mail.</div><div>All this can be triggered with the command &quot;<strong>puppi deploy supersite</strong>&quot; and if something fails you can &quot;puppi rollback supersite&quot;.</div><div>&nbsp;</div><div>The above puppi::project::maven (or tar|war|list|dir|mysql..) defines build up the logic and the sequence of commands run in deployment and rollback operations using basic puppi defines like puppi::project, puppi::deploy, puppi::rollback, puppi::init.</div><div>You can use the existing puppi::project::* procedures or build up your own ones, to manage special cases. The same bash scripts they use (&quot;native scripts&quot;, stored in puppi/files/scripts/) can be replaced by custom scripts, in whatever language.</div><div>&nbsp;</div><div>The other puppi actions require simpler constructs, for example you can manage a single check (we use Nagios plugins, as they are so common) with:</div><div><code>puppi::check { &quot;Port_Apache&quot;:</code></div><div><code>&nbsp; &nbsp; command &nbsp;=&gt; &quot;check_tcp -H ${fqdn} -p 80&quot; ,</code></div><div><code>}</code></div><div>or insert more elaborated checks in your defines (for example when you create virtualhosts, using data you may already provide):</div><div><code>puppi::check { &quot;Url_$name&quot;:</code></div><div><code>&nbsp; &nbsp; enable &nbsp; =&gt; $enable,</code></div><div><code>&nbsp; &nbsp; command &nbsp;=&gt; &quot;check_http -I &#39;${target}&#39; -p &#39;${port}&#39; -u &#39;${url}&#39; -s &#39;${pattern}&#39;&quot; ,</code></div><div><code>}</code></div><div>&nbsp;</div><div>The logs to tail with puppi log are defined by the puppi::log define (note that with a simple selector you can adapt the commands to run according the underlining OS):</div><div><code>puppi::log { &quot;auth&quot;:</code></div><div><code>&nbsp; &nbsp; description =&gt; &quot;Users and authentication&quot; ,</code></div><div><code>&nbsp; &nbsp; log =&gt; $operatingsystem ? {&nbsp;</code></div><div><code>&nbsp; &nbsp; &nbsp; &nbsp; redhat =&gt; &quot;/var/log/secure&quot;,</code></div><div><code>&nbsp; &nbsp; &nbsp; &nbsp; darwin =&gt; &quot;/var/log/secure.log&quot;,</code></div><div><code>&nbsp; &nbsp; &nbsp; &nbsp; ubuntu =&gt; [&quot;/var/log/user.log&quot;,&quot;/var/log/auth.log&quot;],</code></div><div><code>}</code></div><div>Also in this case you can insert a puppi::log inside an existing define, using the data it inherently has:</div><div><code>puppi::log { &quot;tomcat-${instance_name}&quot;:</code></div><div><code>&nbsp; &nbsp; log =&gt; &quot;${tomcat::params::storedir}/${instance_name}/logs/catalina.out&quot;</code></div><div><code>}</code></div><div>&nbsp;</div><div>You can manage the output of &quot;<strong>puppi info network</strong>&quot; with something like:</div><div><code>puppi::info { &quot;network&quot;:</code></div><div><code>&nbsp; &nbsp; description =&gt; &quot;Network settings and stats&quot; ,</code></div><div><code>&nbsp; &nbsp; run &nbsp; &nbsp; &nbsp; &nbsp; =&gt; [ &quot;ifconfig&quot; , &quot;route -n&quot; , &quot;cat /etc/resolv.conf&quot; , &quot;netstat -natup | grep LISTEN&quot; ],</code></div><div><code>}</code></div><div>or build more elaborated info subclasses using custom templates and specific data:</div><div><code>puppi::info::instance { &quot;tomcat-${instance_name}&quot;:</code></div><div><code>&nbsp; &nbsp; servicename =&gt; &quot;tomcat-${instance_name}&quot;,</code></div><div><code>&nbsp; &nbsp; processname =&gt; &quot;${instance_name}&quot;,</code></div><div><code>&nbsp; &nbsp; configdir &nbsp; =&gt; &quot;${tomcat::params::storedir}/${instance_name}/conf/&quot;,</code></div><div><code>&nbsp; &nbsp; bindir &nbsp; &nbsp; &nbsp;=&gt; &quot;${tomcat::params::storedir}/${instance_name}/bin/&quot;,</code></div><div><code>&nbsp; &nbsp; pidfile &nbsp; &nbsp; =&gt; &quot;${instance_rundir}/tomcat-${instance_name}.pid&quot;,</code></div><div><code>&nbsp; &nbsp; datadir &nbsp; &nbsp; =&gt; &quot;${instance_path}/webapps&quot;,</code></div><div><code>&nbsp; &nbsp; logdir &nbsp; &nbsp; &nbsp;=&gt; &quot;${instance_logdir}&quot;,</code></div><div><code>&nbsp; &nbsp; httpport &nbsp; &nbsp;=&gt; &quot;${instance_httpport}&quot;,</code></div><div><code>&nbsp; &nbsp; controlport =&gt; &quot;${instance_controlport}&quot;,</code></div><div><code>&nbsp; &nbsp; ajpport &nbsp; &nbsp; =&gt; &quot;${instance_ajpport}&quot;,</code></div><div><code>&nbsp; &nbsp; description =&gt; &quot;Info for ${instance_name} Tomcat instance&quot; ,</code></div><div><code>}</code></div><div>Examples are endless, you can extend and customize easily the existing defines and you can integrated them in your modules according to the needs you have.</div><div>&nbsp;</div><div><strong>THE JOYS OF COLLECTIVISM</strong></div><div>Puppi&#39;s purpose is not only to provide a command tool based on Puppet data, that helps the sysadmin to gather info, deploy applications, troubleshoot and check them.</div><div>It can be run manually from the local system, automatically via a cron job or triggered by a web interface, it can be used to summarize a set of common actions to be sudoed by non privileged users and it can be called by an agent of an orchestration tool.</div><div>Puppi enters into a new scale with the MCollective agent puppi and the command <strong>mc-puppi</strong>: whatever can be done locally with Puppi, can be repeated on the whole infrastructure, with the same syntax, using the power of MCollective.</div><div>This becomes particularly interesting when your deploy procedures involve actions on different nodes, or when you need to check quickly the systems health on a moltitude on nodes.</div><div>A command like &quot;mc-puppi check&quot; runs and shows the equivalent of ALL your Nagios checks on your WHOLE MCollective domain.</div><div>&nbsp;</div><div>They can be thousands: you have them in few seconds.</div><div>I like to consider this a real-time distributed instant infrastructure test.</div><div>Something like &quot;mc-puppi info network&quot;, instead, provides immediate overview of the network configuration and status of all your nodes, and if verbosity bothers you, just grep what you need.</div><div>&nbsp;</div><div>A missing piece in the puppi world is a web frontend that gathers the reports of the deployments, collects information about nodes, shows the results of local checks and possibly lets users trigger deploy procedures via a central web console.</div><div>The development of a web interface to puppi, altough planned since the beginning, has not yet started.</div><div>The main reason is that it was considered a priority to have a stable command and a mcollective agent, another reason it&#39;s time to make decisions about puppi, and possibly these have to be shared.</div><div>&nbsp;</div><div><strong>FUTURE</strong></div><div>Puppet development is growing quickly, at the Europe PuppetCamp 2011 Luke presented Puppet Faces and it&#39;s clear that version 2.7 introduces us to a new era in Puppet evolution.</div><div>There are some common points in faces and puppi: they both bring parts of Puppet to the cli and they are expandable with actions.</div><div>Actually it just seems natural that puppi&#39;s future is to become a Puppet face.</div><div>Now it&#39;s a bash script that executes bundles of bash scripts, based on data more or less elegantly provided by Puppet modules, it works also on older Puppet versions (at least 0.25) so that it can be widely adopted and integrated in current layouts.</div><div>Next version is probably going to be in ruby, use directly Puppet APIs and possibly be based on a more standardized modules data model. And of course is going to work only with Puppet 2.7 and later.</div><div>It could become something different, maybe even with a different name, but as far as I&#39;m concerned it should keep the principles it&#39;s based upon:</div><div>- Be based on Puppet data: Puppet knows the infrastructure, we want this knowledge and intelligence integrated in commands we run on the shell. The way this data is currently provided is not optimized (every piece of puppi information is basically a Puppet resource (generally a file) and this is an overhead we should avoid), we could rely directly on the catalog, which seems the most natural source, but in order to do this I suspect some kind of standardization is needed at the module level.</div><div>- Provide a simple single line standard command to run an application deployment (one keystroke to deploy them all)</div><div>- Provide useful actions that can be used from the cli, an orchestrator agent or a web interface to show info, status and working details on systems and applications (I would keep the check/info/log actions, as I&#39;m finding them quite useful)</div><div>- It can be run manually or automatically, locally or from a central orchestrator and, possibly, also via a web interface.</div><div>A puppi webapp should let different users request, trigger and view the results of a deploy, gather info from the systems (via rest?), in order to become an inventory frontend on steroids with as much detail on the system as users want, receive and show checks and possibly be able to search and correlate the large amount of data it could receive.</div><div>Truth is that development on the next puppi and its web frontend is something that I would like to do in collaboration with PuppetLabs and who is interested in the community.</div><div>Puppi 1.0 was done by me for a customer&#39;s needs with the knowledge and the requirents I had at disposal.</div><div>Puppi 2.0 (whatever the name and the shape) has not immediate operative requirements, its design, how data is feeded from modules, how it&#39;s integrated in Puppet should be discussed and shared.</div><div>Anyone interested?</div>
